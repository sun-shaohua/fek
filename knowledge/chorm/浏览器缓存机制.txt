浏览器缓存机制

1.什么是缓存
  浏览器缓存就是保存通过Http获取到的资源，是浏览器将网络资源保存到本地的一种行为
2.为什么需要缓存
  使用缓存机制可以缓解服务器端压力，减小带宽，提高网页的相应时间
3.缓存机制在那一步进行了优化
  第一步发起网络请求，第二步后端出来返回数据，第三步浏览器相应，浏览器的缓存机制在第一步和第三步之间
4.缓存资源在哪里
  缓存位置分为四种，并且各有个的优先级，当依次查找缓存，没有找到是去请求网络
  （1）service worker
    运行在浏览器背后的独立线程，一般可以用来实现缓存功能。
    使用Service Worker的话，传输协议必须是HTTPS，因为Service Worker中涉及到请求拦截。
    Service Worker的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
    如果需要向服务器发起请求的就转给服务器，如果可以直接使用缓存的就直接返回缓存不再转给服务器。
    Service Worker 实现缓存一般分为三个步骤：首先需要注册Service Worker ；然后监听到install事件以后就可以缓存需要的文件；在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在的话就直接读取，否则就去请求数据。
    当Service Worker 没有命中缓存的时候，需要去调用fetch函数获取数据，也就是说，如果没有在Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据，但是不管是从Memory Cache还是网络请求中获取的数据，浏览器都会显示是从Service Worker 获取的。
  （2）memory cache
    memory cache就是将资源放到内存中，等下次访问就不需要重新下载，而直接从内存中直接获取，
    主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，但是内存缓存持续性短，会随着进程的释放而释放，一旦关闭tab页面，内存中的缓存就释放了。
    当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。内存缓存中有一块重要的缓存资源就是preloader指令（例如<link rel="prefetch">）下载的资源。众所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。
    需要注意的是，内存缓存在缓存资源时不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type、CORS 等其他特征做校验。
  （3）disk cache
    Disk Cache 就是将资源缓存在磁盘里，等待下次访问时不需要重新下载资源，直接从磁盘中获取，它的直接操作对象是CurlCacheManager。
    读取速度慢点，与Memory Cache相比，胜在容量和存储时效上。
    在所有浏览器缓存中，Disk Cache覆盖面基本是最大的。它会根据HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，以及哪些资源已经过期需要重新请求。
    而且在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据，绝大部分的缓存都来自Disk Cache，关于HTTP的协议头中的缓存字段，会在下文中详细介绍。

  缓存位置	  Memory Cache	                Disk Cache
  相同点	      只能存储一些派生类资源文件	        只能存储一些派生类资源文件
  不同点	      退出进程时数据会被清除	        退出进程时数据不会被清除
  存储资源	  一般脚本、字体、图片会存在内存当中	一般非脚本会存在内存当中，如CSS等
5.缓存策略
  出于性能的考虑，到部分的接口都应该做好缓存策略。通常浏览器的缓存策略分为两种：强缓存和协商缓存，并且通过设置HTTP Header来实现。
  浏览器请求资源是，首先判断是否命中强缓存，在判断是否命中协商缓存
  （1）强缓存
    强缓存不会向服务器发送请求，直接从缓存中换取资源，在Chrome的network中可以看到请求返回的状态码是200，在size中显示的是from memory cache或者 from disk chore
    HTTP header中的expires和cache-control,优先级：cache-control > expires
    expires 指缓存过期时间，用来指定资源的过期时间，时间格式GMT格式的时间字符串，缺点：服务器端和客户端的时间偏差比较大
    cache-control no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。
                  no-store：禁止使用缓存，每一次都要重新请求数据。
                  public：可以被所有用户缓存，包括终端用户和CDN等中间代理服务器。
                  private：只能被终端用户的浏览器缓存，不允许CDN等中间代理服务器对其缓存。
                  s-max-age=30：覆盖max-age，作用一样，只在代理服务器生效
                  max-stale=30：30秒内，即使缓存过期，也使用该缓存
                  min-fresh=30：希望在30秒内获取最新的响应。
  （2）协商缓存
   当强缓存没有命中的时候，浏览器会发送请求到服务器，服务器格局header中的部分信息判断是否命中缓存，如果命中，则返回304，告诉浏览器资源未更新，可以使用本地缓存
   HTTP header 中的信息指的是Last-Modify/If-Modify-Since 和 ETag/If-none-Match。

   浏览器第一次请求一个资源时，服务器返回的response header中会加上Last-Modified，Last-Modified是一个时间标识该资源的最后修改时间。
   Last-Modified：Fri，22 Jul 2016 01:47:00 GMT
   当浏览器再次请求该资源时，request的请求头中会包含If-Modified-Since，该值为缓存之前返回的Last-Modified。
   服务器收到If-Modified-Since后，根据资源的最后修改时间判断是否命中缓存。如果命中，返回304，并且不会返回资源内容，并且不会返回Last-Modified。

6.用户行为对浏览器的影响
所谓用户行为对浏览器缓存的影响，指的是用户在浏览器如何操作时，会触发怎样的缓存策略，主要分三种：

打开网页，地址栏输入地址：查找disk cache中是否有匹配，如有则使用，如没有则发送网略请求。
普通刷新（F5）：跳过强缓存，会检查协商缓存。因为TAB页没有被关闭，因此memory cache 是可用的，会被优先使用，其次才是disk cache。
强制刷新（Ctrl+F5）：浏览器不使用缓存，直接从服务器加载，跳过强缓存和协商缓存，因此发送的请求头部均带有Cache-control：no-cache（为了兼容，还带了pragma：no-cache），服务器直接返回200和最新内容

7.缓存的种类
 cookie webStorage(localStorage|sessionStorage),indexedDB

